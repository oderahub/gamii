'use client';

/**
 * Tournament Lobby
 *
 * Powered by Hedera Token Service (HTS)
 * - Browse active tournaments
 * - Purchase TOURNAMENT_TICKET NFTs
 * - View prize pools and distributions
 */

import { useState, useEffect } from 'react';
import {
  getActiveTournaments,
  getTournament,
  purchaseTournamentTicket,
  type Tournament,
} from '~/lib/hedera/tournaments';
import { useHashPack } from '~/hooks/useHashPack';
import { formatPokerChips } from '~/lib/hedera/tokens';
import { Button } from '~/components/ui/button';
import { Skeleton } from '~/components/ui/skeleton';
import { cn } from '~/lib/utils';
import { Trophy, Users, Clock, Coins } from 'lucide-react';

export function TournamentLobby() {
  const { accountId, chipBalance } = useHashPack();
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [loading, setLoading] = useState(true);
  const [purchasing, setPurchasing] = useState<string | null>(null);

  useEffect(() => {
    async function loadTournaments() {
      try {
        const data = await getActiveTournaments();
        setTournaments(data);
      } catch (error) {
        console.error('Failed to load tournaments:', error);
      } finally {
        setLoading(false);
      }
    }

    loadTournaments();

    // Refresh every 10 seconds
    const interval = setInterval(loadTournaments, 10000);
    return () => clearInterval(interval);
  }, []);

  const handlePurchaseTicket = async (tournament: Tournament) => {
    if (!accountId) {
      alert('Please connect your HashPack wallet first');
      return;
    }

    if (chipBalance < tournament.buyIn) {
      alert('Insufficient POKER_CHIP balance');
      return;
    }

    setPurchasing(tournament.id);
    try {
      const ticketSerial = await purchaseTournamentTicket(
        accountId,
        tournament.id,
        tournament.buyIn
      );

      alert(`Tournament ticket purchased! Serial #${ticketSerial}`);

      // Refresh tournament data
      const updated = await getTournament(tournament.id);
      if (updated) {
        setTournaments((prev) =>
          prev.map((t) => (t.id === updated.id ? updated : t))
        );
      }
    } catch (error) {
      console.error('Purchase failed:', error);
      alert('Failed to purchase ticket. Please try again.');
    } finally {
      setPurchasing(null);
    }
  };

  if (loading) {
    return (
      <div className="space-y-4">
        <Skeleton className="h-12 w-full" />
        <Skeleton className="h-64 w-full" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Tournaments</h1>
          <p className="text-muted-foreground">
            Join poker tournaments and win prizes
          </p>
        </div>
        {accountId && (
          <div className="text-right">
            <p className="text-sm text-muted-foreground">Your Balance</p>
            <p className="text-2xl font-bold">
              {formatPokerChips(chipBalance)} CHIP
            </p>
          </div>
        )}
      </div>

      {/* Tournament List */}
      {tournaments.length === 0 ? (
        <div className="border rounded-lg p-12 text-center">
          <Trophy className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
          <h3 className="text-lg font-semibold mb-2">No Active Tournaments</h3>
          <p className="text-sm text-muted-foreground">
            Check back later for upcoming tournaments
          </p>
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2">
          {tournaments.map((tournament) => (
            <TournamentCard
              key={tournament.id}
              tournament={tournament}
              onPurchase={() => handlePurchaseTicket(tournament)}
              purchasing={purchasing === tournament.id}
              canPurchase={!!accountId && chipBalance >= tournament.buyIn}
              isRegistered={tournament.registeredPlayers.includes(accountId || '')}
            />
          ))}
        </div>
      )}
    </div>
  );
}

interface TournamentCardProps {
  tournament: Tournament;
  onPurchase: () => void;
  purchasing: boolean;
  canPurchase: boolean;
  isRegistered: boolean;
}

function TournamentCard({
  tournament,
  onPurchase,
  purchasing,
  canPurchase,
  isRegistered,
}: TournamentCardProps) {
  const startDate = new Date(tournament.startTime);
  const now = Date.now();
  const timeUntilStart = tournament.startTime - now;
  const hasStarted = timeUntilStart <= 0;

  const spotsRemaining = tournament.maxPlayers - tournament.currentPlayers;
  const isFull = spotsRemaining <= 0;

  return (
    <div
      className={cn(
        'border rounded-lg p-6 space-y-4',
        tournament.status === 'active' && 'border-green-500 bg-green-500/5',
        isFull && 'opacity-60'
      )}
    >
      {/* Header */}
      <div className="flex items-start justify-between">
        <div>
          <h3 className="text-xl font-bold mb-1">{tournament.name}</h3>
          <p className="text-sm text-muted-foreground">
            {tournament.description}
          </p>
        </div>
        <StatusBadge status={tournament.status} />
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-2 gap-4">
        <StatItem
          icon={<Coins className="h-4 w-4" />}
          label="Buy-in"
          value={formatPokerChips(tournament.buyIn)}
        />
        <StatItem
          icon={<Trophy className="h-4 w-4" />}
          label="Prize Pool"
          value={formatPokerChips(tournament.prizePool)}
        />
        <StatItem
          icon={<Users className="h-4 w-4" />}
          label="Players"
          value={`${tournament.currentPlayers}/${tournament.maxPlayers}`}
        />
        <StatItem
          icon={<Clock className="h-4 w-4" />}
          label={hasStarted ? 'Started' : 'Starts'}
          value={
            hasStarted
              ? 'Now'
              : timeUntilStart < 3600000
              ? `${Math.floor(timeUntilStart / 60000)}m`
              : startDate.toLocaleTimeString([], {
                  hour: '2-digit',
                  minute: '2-digit',
                })
          }
        />
      </div>

      {/* Prize Distribution */}
      <div className="border-t pt-4">
        <p className="text-sm font-semibold mb-2">Prize Distribution</p>
        <div className="flex gap-2">
          {tournament.prizeDistribution.map((percentage, idx) => (
            <div
              key={idx}
              className="flex-1 text-center p-2 bg-muted rounded text-sm"
            >
              <p className="font-semibold">{percentage}%</p>
              <p className="text-xs text-muted-foreground">
                {idx === 0 && 'ðŸ¥‡'}
                {idx === 1 && 'ðŸ¥ˆ'}
                {idx === 2 && 'ðŸ¥‰'}
                {idx > 2 && `${idx + 1}th`}
              </p>
            </div>
          ))}
        </div>
      </div>

      {/* Action Button */}
      <div className="border-t pt-4">
        {isRegistered ? (
          <Button className="w-full" disabled>
            Registered âœ“
          </Button>
        ) : isFull ? (
          <Button className="w-full" disabled>
            Tournament Full
          </Button>
        ) : hasStarted && tournament.status === 'active' ? (
          <Button className="w-full" disabled>
            In Progress
          </Button>
        ) : (
          <Button
            className="w-full"
            onClick={onPurchase}
            disabled={!canPurchase || purchasing}
          >
            {purchasing
              ? 'Purchasing...'
              : `Purchase Ticket (${formatPokerChips(tournament.buyIn)} CHIP)`}
          </Button>
        )}

        {!canPurchase && !isRegistered && !isFull && (
          <p className="text-xs text-red-500 text-center mt-2">
            Insufficient balance
          </p>
        )}

        {spotsRemaining <= 5 && spotsRemaining > 0 && !isFull && (
          <p className="text-xs text-orange-500 text-center mt-2">
            Only {spotsRemaining} spots remaining!
          </p>
        )}
      </div>
    </div>
  );
}

function StatusBadge({ status }: { status: Tournament['status'] }) {
  const colors = {
    upcoming: 'bg-blue-500',
    registration: 'bg-green-500',
    active: 'bg-yellow-500',
    completed: 'bg-gray-500',
    cancelled: 'bg-red-500',
  };

  return (
    <div
      className={cn(
        'px-3 py-1 rounded-full text-xs font-semibold text-white',
        colors[status]
      )}
    >
      {status.toUpperCase()}
    </div>
  );
}

function StatItem({
  icon,
  label,
  value,
}: {
  icon: React.ReactNode;
  label: string;
  value: string;
}) {
  return (
    <div className="flex items-center gap-2">
      <div className="text-muted-foreground">{icon}</div>
      <div>
        <p className="text-xs text-muted-foreground">{label}</p>
        <p className="font-semibold">{value}</p>
      </div>
    </div>
  );
}

/**
 * Create Tournament Form
 */
export function CreateTournamentForm({
  onCreated,
}: {
  onCreated?: (tournament: Tournament) => void;
}) {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [buyIn, setBuyIn] = useState('10000'); // 100.00 CHIP
  const [maxPlayers, setMaxPlayers] = useState('100');
  const [creating, setCreating] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    setCreating(true);
    try {
      const { createTournament } = await import('~/lib/hedera/tournaments');

      const tournament = await createTournament(
        name,
        description,
        parseInt(buyIn),
        parseInt(maxPlayers),
        Date.now() + 3600000, // Start in 1 hour
        [50, 30, 20] // Default prize distribution
      );

      onCreated?.(tournament);

      // Reset form
      setName('');
      setDescription('');
      setBuyIn('10000');
      setMaxPlayers('100');

      alert('Tournament created successfully!');
    } catch (error) {
      console.error('Failed to create tournament:', error);
      alert('Failed to create tournament');
    } finally {
      setCreating(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4 border rounded-lg p-6">
      <h2 className="text-2xl font-bold">Create Tournament</h2>

      <div>
        <label className="block text-sm font-medium mb-2">Name</label>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          className="w-full px-3 py-2 border rounded-lg"
          required
        />
      </div>

      <div>
        <label className="block text-sm font-medium mb-2">Description</label>
        <textarea
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          className="w-full px-3 py-2 border rounded-lg"
          rows={3}
          required
        />
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium mb-2">
            Buy-in (CHIP)
          </label>
          <input
            type="number"
            value={buyIn}
            onChange={(e) => setBuyIn(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            min="100"
            step="100"
            required
          />
          <p className="text-xs text-muted-foreground mt-1">
            {formatPokerChips(parseInt(buyIn))} CHIP
          </p>
        </div>

        <div>
          <label className="block text-sm font-medium mb-2">Max Players</label>
          <input
            type="number"
            value={maxPlayers}
            onChange={(e) => setMaxPlayers(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            min="2"
            max="1000"
            required
          />
        </div>
      </div>

      <Button type="submit" className="w-full" disabled={creating}>
        {creating ? 'Creating...' : 'Create Tournament'}
      </Button>
    </form>
  );
}
