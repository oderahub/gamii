/**
 * Tournament System
 *
 * Manages poker tournaments using Hedera Token Service (HTS) NFTs.
 * - TOURNAMENT_TICKET NFTs for entry
 * - Prize distribution with POKER_CHIP tokens
 * - Tournament state tracking via HCS
 */

import { mintNFT, transferNFT, transferPokerChips, TOKENS } from './tokens';
import { submitHCSMessage, getTopicMessages } from './hcs';

export interface Tournament {
  id: string;
  name: string;
  description: string;
  buyIn: number; // in POKER_CHIP
  maxPlayers: number;
  currentPlayers: number;
  startTime: number;
  prizePool: number;
  status: 'upcoming' | 'registration' | 'active' | 'completed' | 'cancelled';
  registeredPlayers: string[];
  prizeDistribution: number[]; // Percentages for 1st, 2nd, 3rd, etc.
  minPlayers: number;
}

export interface TournamentResult {
  tournamentId: string;
  rankings: {
    position: number;
    playerAddress: string;
    prize: number;
  }[];
  totalPrizePool: number;
  timestamp: number;
}

/**
 * Create a new tournament
 *
 * @param name - Tournament name
 * @param description - Tournament description
 * @param buyIn - Entry fee in POKER_CHIP (with 2 decimals)
 * @param maxPlayers - Maximum number of players
 * @param startTime - Unix timestamp for tournament start
 * @param prizeDistribution - Prize percentages (e.g., [50, 30, 20] for 1st, 2nd, 3rd)
 * @returns Tournament object
 */
export async function createTournament(
  name: string,
  description: string,
  buyIn: number,
  maxPlayers: number,
  startTime: number,
  prizeDistribution: number[] = [50, 30, 20]
): Promise<Tournament> {
  try {
    const tournament: Tournament = {
      id: `tournament-${Date.now()}`,
      name,
      description,
      buyIn,
      maxPlayers,
      currentPlayers: 0,
      startTime,
      prizePool: 0,
      status: 'registration',
      registeredPlayers: [],
      prizeDistribution,
      minPlayers: 2,
    };

    // Publish tournament creation to HCS
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (topicId) {
      await submitHCSMessage(topicId, {
        type: 'TOURNAMENT_CREATED',
        gameId: tournament.id,
        playerId: undefined,
        data: tournament,
      });
    }

    console.log(`✅ Tournament created: ${tournament.id}`);
    return tournament;
  } catch (error) {
    console.error('Failed to create tournament:', error);
    throw error;
  }
}

/**
 * Purchase tournament ticket (NFT)
 *
 * @param accountId - Player's Hedera account ID
 * @param tournamentId - Tournament ID
 * @param buyInAmount - Amount of POKER_CHIP to transfer
 * @returns NFT serial number
 */
export async function purchaseTournamentTicket(
  accountId: string,
  tournamentId: string,
  buyInAmount: number
): Promise<string> {
  try {
    // 1. Transfer POKER_CHIP buy-in to tournament pool
    const treasuryAccount = process.env.HEDERA_ACCOUNT_ID || process.env.NEXT_PUBLIC_HEDERA_ACCOUNT_ID;
    if (!treasuryAccount) {
      throw new Error('Treasury account not configured');
    }

    await transferPokerChips(accountId, treasuryAccount, buyInAmount);

    // 2. Mint TOURNAMENT_TICKET NFT with metadata
    const metadata = JSON.stringify({
      tournamentId,
      purchaseDate: Date.now(),
      buyIn: buyInAmount,
      status: 'active',
    });

    const serialNumber = await mintNFT(
      TOKENS.TOURNAMENT_TICKET,
      accountId,
      metadata
    );

    // 3. Publish registration to HCS
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (topicId) {
      await submitHCSMessage(topicId, {
        type: 'TOURNAMENT_REGISTRATION',
        gameId: tournamentId,
        playerId: accountId,
        data: {
          ticketSerial: serialNumber.toString(),
          buyIn: buyInAmount,
        },
      });
    }

    console.log(`✅ Tournament ticket purchased: #${serialNumber}`);
    return serialNumber.toString();
  } catch (error) {
    console.error('Failed to purchase tournament ticket:', error);
    throw error;
  }
}

/**
 * Get tournament details
 *
 * @param tournamentId - Tournament ID
 * @returns Tournament object with latest data
 */
export async function getTournament(tournamentId: string): Promise<Tournament | null> {
  try {
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      return null;
    }

    const events = await getTopicMessages(topicId);

    // Find tournament creation event
    const createEvent = events.find(
      (e) => e.type === 'TOURNAMENT_CREATED' && e.gameId === tournamentId
    );

    if (!createEvent) {
      return null;
    }

    const tournament = createEvent.data as Tournament;

    // Get all registrations
    const registrations = events.filter(
      (e) => e.type === 'TOURNAMENT_REGISTRATION' && e.gameId === tournamentId
    );

    tournament.currentPlayers = registrations.length;
    tournament.registeredPlayers = registrations.map((e) => e.playerId || '');
    tournament.prizePool = registrations.length * tournament.buyIn;

    // Check if tournament should start
    if (
      tournament.status === 'registration' &&
      tournament.currentPlayers >= tournament.minPlayers &&
      Date.now() >= tournament.startTime
    ) {
      tournament.status = 'active';
    }

    return tournament;
  } catch (error) {
    console.error('Failed to get tournament:', error);
    return null;
  }
}

/**
 * Get all active tournaments
 *
 * @returns Array of active tournaments
 */
export async function getActiveTournaments(): Promise<Tournament[]> {
  try {
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      return [];
    }

    const events = await getTopicMessages(topicId);

    // Find all tournament creation events
    const createEvents = events.filter((e) => e.type === 'TOURNAMENT_CREATED');

    // Get tournament details for each
    const tournaments = await Promise.all(
      createEvents.map((e) => getTournament(e.gameId))
    );

    // Filter out nulls and completed tournaments
    return tournaments.filter(
      (t): t is Tournament => t !== null && t.status !== 'completed'
    );
  } catch (error) {
    console.error('Failed to get active tournaments:', error);
    return [];
  }
}

/**
 * Distribute tournament prizes
 *
 * @param tournamentId - Tournament ID
 * @param rankings - Array of player addresses in order of finish
 */
export async function distributeTournamentPrizes(
  tournamentId: string,
  rankings: string[]
): Promise<TournamentResult> {
  try {
    const tournament = await getTournament(tournamentId);
    if (!tournament) {
      throw new Error('Tournament not found');
    }

    const treasuryAccount = process.env.HEDERA_ACCOUNT_ID || process.env.NEXT_PUBLIC_HEDERA_ACCOUNT_ID;
    if (!treasuryAccount) {
      throw new Error('Treasury account not configured');
    }

    const results: TournamentResult = {
      tournamentId,
      rankings: [],
      totalPrizePool: tournament.prizePool,
      timestamp: Date.now(),
    };

    // Distribute prizes based on prize distribution
    for (let i = 0; i < Math.min(rankings.length, tournament.prizeDistribution.length); i++) {
      const playerAddress = rankings[i];
      const prizePercentage = tournament.prizeDistribution[i];
      const prize = (tournament.prizePool * prizePercentage) / 100;

      // Transfer POKER_CHIP prize
      await transferPokerChips(treasuryAccount, playerAddress, Math.floor(prize));

      // Mint achievement badge NFT
      const metadata = JSON.stringify({
        tournamentId,
        tournamentName: tournament.name,
        position: i + 1,
        prize,
        date: Date.now(),
      });

      await mintNFT(TOKENS.ACHIEVEMENT_BADGE, playerAddress, metadata);

      results.rankings.push({
        position: i + 1,
        playerAddress,
        prize,
      });
    }

    // Publish results to HCS
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (topicId) {
      await submitHCSMessage(topicId, {
        type: 'TOURNAMENT_COMPLETED',
        gameId: tournamentId,
        playerId: undefined,
        data: results,
      });
    }

    console.log(`✅ Tournament prizes distributed: ${tournamentId}`);
    return results;
  } catch (error) {
    console.error('Failed to distribute tournament prizes:', error);
    throw error;
  }
}

/**
 * Cancel tournament and refund players
 *
 * @param tournamentId - Tournament ID
 */
export async function cancelTournament(tournamentId: string): Promise<void> {
  try {
    const tournament = await getTournament(tournamentId);
    if (!tournament) {
      throw new Error('Tournament not found');
    }

    const treasuryAccount = process.env.HEDERA_ACCOUNT_ID || process.env.NEXT_PUBLIC_HEDERA_ACCOUNT_ID;
    if (!treasuryAccount) {
      throw new Error('Treasury account not configured');
    }

    // Refund all registered players
    for (const playerAddress of tournament.registeredPlayers) {
      await transferPokerChips(treasuryAccount, playerAddress, tournament.buyIn);
    }

    // Publish cancellation to HCS
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (topicId) {
      await submitHCSMessage(topicId, {
        type: 'TOURNAMENT_CANCELLED',
        gameId: tournamentId,
        playerId: undefined,
        data: {
          refundedPlayers: tournament.registeredPlayers.length,
          totalRefunded: tournament.prizePool,
        },
      });
    }

    console.log(`✅ Tournament cancelled and refunded: ${tournamentId}`);
  } catch (error) {
    console.error('Failed to cancel tournament:', error);
    throw error;
  }
}

/**
 * Get player's tournament history
 *
 * @param playerAddress - Player address
 * @returns Array of tournaments the player participated in
 */
export async function getPlayerTournaments(
  playerAddress: string
): Promise<Tournament[]> {
  try {
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      return [];
    }

    const events = await getTopicMessages(topicId);

    // Find all tournaments player registered for
    const registrations = events.filter(
      (e) =>
        e.type === 'TOURNAMENT_REGISTRATION' &&
        e.playerId?.toLowerCase() === playerAddress.toLowerCase()
    );

    const tournamentIds = [...new Set(registrations.map((e) => e.gameId))];

    // Get tournament details
    const tournaments = await Promise.all(
      tournamentIds.map((id) => getTournament(id))
    );

    return tournaments.filter((t): t is Tournament => t !== null);
  } catch (error) {
    console.error('Failed to get player tournaments:', error);
    return [];
  }
}

/**
 * Example usage:
 *
 * ```typescript
 * // Create tournament
 * const tournament = await createTournament(
 *   'Sunday Million',
 *   'Weekly high-stakes tournament',
 *   10000, // 100.00 CHIP buy-in
 *   100,   // max players
 *   Date.now() + 3600000, // starts in 1 hour
 *   [50, 30, 20] // prize distribution
 * );
 *
 * // Purchase ticket
 * const ticketSerial = await purchaseTournamentTicket(
 *   '0.0.123456',
 *   tournament.id,
 *   10000
 * );
 *
 * // Get tournament status
 * const updated = await getTournament(tournament.id);
 * console.log(`${updated.currentPlayers}/${updated.maxPlayers} registered`);
 *
 * // Distribute prizes (admin function)
 * const results = await distributeTournamentPrizes(
 *   tournament.id,
 *   ['0x...winner', '0x...second', '0x...third']
 * );
 * ```
 */
