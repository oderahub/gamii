/**
 * Player Statistics Aggregator
 *
 * Aggregates player performance data from HCS game events.
 * Provides insights like win rate, total winnings, favorite actions, etc.
 */

import { getTopicMessages, submitHCSMessage, MessageType } from './hcs';

export interface PlayerStats {
  playerAddress: string;
  gamesPlayed: number;
  gamesWon: number;
  totalWinnings: number;
  totalLosses: number;
  biggestPot: number;
  winRate: number;
  favoriteAction: string;
  totalHands: number;
  averagePot: number;
  lastPlayed: number;
}

export interface GameSummary {
  gameId: string;
  timestamp: number;
  result: 'won' | 'lost';
  pot: number;
  position: number;
}

/**
 * Get comprehensive player statistics
 *
 * @param playerAddress - Player's wallet address
 * @returns Aggregated statistics
 */
export async function getPlayerStats(playerAddress: string): Promise<PlayerStats> {
  try {
    // Get all game events from HCS
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      throw new Error('GAME_EVENTS_TOPIC_ID not configured');
    }

    const events = await getTopicMessages(topicId);

    // Filter events for this player
    const playerEvents = events.filter(
      (e) => e.playerId?.toLowerCase() === playerAddress.toLowerCase()
    );

    // Initialize stats
    const stats: PlayerStats = {
      playerAddress,
      gamesPlayed: 0,
      gamesWon: 0,
      totalWinnings: 0,
      totalLosses: 0,
      biggestPot: 0,
      winRate: 0,
      favoriteAction: '',
      totalHands: 0,
      averagePot: 0,
      lastPlayed: 0,
    };

    // Track unique games and actions
    const gameIds = new Set<string>();
    const actionCounts: Record<string, number> = {};
    const pots: number[] = [];

    // Process events
    for (const event of playerEvents) {
      if (event.gameId) {
        gameIds.add(event.gameId);
      }

      // Track last played time
      if (event.timestamp > stats.lastPlayed) {
        stats.lastPlayed = event.timestamp;
      }

      // Count actions
      if (event.type === MessageType.PLAYER_ACTION) {
        const action = event.data.action as string;
        actionCounts[action] = (actionCounts[action] || 0) + 1;
      }

      // Track game results
      if (event.type === MessageType.GAME_ENDED) {
        const pot = parseFloat(event.data.pot || '0');
        pots.push(pot);

        if (
          event.data.winner?.toLowerCase() === playerAddress.toLowerCase()
        ) {
          stats.gamesWon++;
          stats.totalWinnings += pot;
          stats.biggestPot = Math.max(stats.biggestPot, pot);
        } else {
          stats.totalLosses += parseFloat(event.data.buyIn || '0');
        }
      }

      // Count hands
      if (event.type === MessageType.HAND_DEALT) {
        stats.totalHands++;
      }
    }

    // Calculate derived stats
    stats.gamesPlayed = gameIds.size;
    stats.winRate =
      stats.gamesPlayed > 0 ? (stats.gamesWon / stats.gamesPlayed) * 100 : 0;
    stats.favoriteAction =
      Object.entries(actionCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'none';
    stats.averagePot =
      pots.length > 0 ? pots.reduce((a, b) => a + b, 0) / pots.length : 0;

    return stats;
  } catch (error) {
    console.error('Failed to get player stats:', error);
    throw error;
  }
}

/**
 * Get player's game history
 *
 * @param playerAddress - Player's wallet address
 * @param limit - Maximum number of games to return
 * @returns Array of game summaries
 */
export async function getPlayerGameHistory(
  playerAddress: string,
  limit = 10
): Promise<GameSummary[]> {
  try {
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      throw new Error('GAME_EVENTS_TOPIC_ID not configured');
    }

    const events = await getTopicMessages(topicId);

    // Find all games where player participated
    const gameEndEvents = events.filter(
      (e) =>
        e.type === MessageType.GAME_ENDED &&
        (e.data.players as string[])?.some(
          (p) => p.toLowerCase() === playerAddress.toLowerCase()
        )
    );

    // Convert to game summaries
    const summaries: GameSummary[] = gameEndEvents
      .filter((event) => event.gameId !== undefined)
      .map((event) => {
        const players = event.data.players as string[];
        const winner = event.data.winner as string;
        const pot = parseFloat(event.data.pot || '0');

        return {
          gameId: event.gameId!,
          timestamp: event.timestamp,
          result:
            winner?.toLowerCase() === playerAddress.toLowerCase()
              ? ('won' as const)
              : ('lost' as const),
          pot,
          position:
            players.findIndex(
              (p) => p.toLowerCase() === playerAddress.toLowerCase()
            ) + 1,
        };
      })
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);

    return summaries;
  } catch (error) {
    console.error('Failed to get player game history:', error);
    throw error;
  }
}

/**
 * Get leaderboard
 *
 * @param limit - Number of top players to return
 * @returns Array of player stats sorted by winnings
 */
export async function getLeaderboard(limit = 10): Promise<PlayerStats[]> {
  try {
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      throw new Error('GAME_EVENTS_TOPIC_ID not configured');
    }

    const events = await getTopicMessages(topicId);

    // Get unique player addresses
    const playerAddresses = new Set<string>();
    events.forEach((e) => {
      if (e.playerId) {
        playerAddresses.add(e.playerId.toLowerCase());
      }
      if (e.data.players) {
        (e.data.players as string[]).forEach((p) =>
          playerAddresses.add(p.toLowerCase())
        );
      }
    });

    // Get stats for each player
    const allStats = await Promise.all(
      Array.from(playerAddresses).map((addr) => getPlayerStats(addr))
    );

    // Sort by total winnings and return top N
    return allStats
      .sort((a, b) => b.totalWinnings - a.totalWinnings)
      .slice(0, limit);
  } catch (error) {
    console.error('Failed to get leaderboard:', error);
    throw error;
  }
}

/**
 * Submit a stats update event to HCS
 * This can be used to trigger stats recalculation
 *
 * @param playerAddress - Player address
 * @param stats - Partial stats to update
 */
export async function submitStatsUpdate(
  playerAddress: string,
  stats: Partial<PlayerStats>
): Promise<void> {
  try {
    const topicId = process.env.NEXT_PUBLIC_GAME_EVENTS_TOPIC_ID;
    if (!topicId) {
      throw new Error('GAME_EVENTS_TOPIC_ID not configured');
    }

    await submitHCSMessage(topicId, {
      type: 'STATS_UPDATE',
      playerId: playerAddress,
      gameId: 'system',
      data: stats,
    });
  } catch (error) {
    console.error('Failed to submit stats update:', error);
    throw error;
  }
}

/**
 * Calculate player rank based on win rate and games played
 *
 * @param stats - Player statistics
 * @returns Rank name and tier
 */
export function getPlayerRank(stats: PlayerStats): {
  name: string;
  tier: number;
  color: string;
} {
  const { winRate, gamesPlayed } = stats;

  // Need minimum games to be ranked
  if (gamesPlayed < 5) {
    return { name: 'Unranked', tier: 0, color: 'gray' };
  }

  // Calculate rank based on win rate
  if (winRate >= 70) {
    return { name: 'Legend', tier: 7, color: 'purple' };
  } else if (winRate >= 60) {
    return { name: 'Master', tier: 6, color: 'gold' };
  } else if (winRate >= 55) {
    return { name: 'Diamond', tier: 5, color: 'blue' };
  } else if (winRate >= 50) {
    return { name: 'Platinum', tier: 4, color: 'cyan' };
  } else if (winRate >= 45) {
    return { name: 'Gold', tier: 3, color: 'yellow' };
  } else if (winRate >= 40) {
    return { name: 'Silver', tier: 2, color: 'silver' };
  } else {
    return { name: 'Bronze', tier: 1, color: 'bronze' };
  }
}

/**
 * Example usage:
 *
 * ```typescript
 * // Get player stats
 * const stats = await getPlayerStats('0x...');
 * console.log(`Win rate: ${stats.winRate}%`);
 * console.log(`Total winnings: ${stats.totalWinnings} HBAR`);
 *
 * // Get game history
 * const history = await getPlayerGameHistory('0x...', 10);
 * history.forEach(game => {
 *   console.log(`${game.result}: ${game.pot} HBAR`);
 * });
 *
 * // Get leaderboard
 * const leaderboard = await getLeaderboard(10);
 * leaderboard.forEach((player, idx) => {
 *   console.log(`#${idx + 1}: ${player.playerAddress} - ${player.totalWinnings} HBAR`);
 * });
 *
 * // Get player rank
 * const rank = getPlayerRank(stats);
 * console.log(`Rank: ${rank.name} (Tier ${rank.tier})`);
 * ```
 */
